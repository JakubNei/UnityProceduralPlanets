#pragma kernel generateUsingPlanetGlobalPos
#pragma kernel generateUsingChunkLocalPos

#include "Planet.Compute.cginc"



Texture2D<float> _chunkHeightMap;
SamplerState sampler_chunkHeightMap;

Texture2D<float2> _chunkSlopeAndCurvatureMap;
SamplerState sampler_chunkSlopeAndCurvatureMap;

int _numberOfVerticesOnEdge;
float _planetRadiusStart;
float _planetRadiusHeightMapMultiplier;

float3 _rangeUnitCubePosA;
float3 _rangeUnitCubePosB;
float3 _rangeUnitCubePosC;
float3 _rangeUnitCubePosD;

float _heightMin;
float _heightMax;

float _moveEdgeVerticesDown;


RWStructuredBuffer<float3> _vertices;


StructuredBuffer<float4> _craterSpherePositionRadius;


[numthreads(1, 1, 1)]
void generateUsingPlanetGlobalPos(uint3 id : SV_DispatchThreadID)
{
	float max = _numberOfVerticesOnEdge - 1;
	float2 uv = float2(id.x / max, id.y / max);

	float3 unitCubePos = lerp(
		lerp(_rangeUnitCubePosA, _rangeUnitCubePosB, uv.x),
		lerp(_rangeUnitCubePosD, _rangeUnitCubePosC, uv.x),
		uv.y
	);

	float3 dir = unitCubeToUnitSphere(unitCubePos);

	float height = _chunkHeightMap.SampleLevel(sampler_chunkHeightMap, uv, 0).r;
	height = height * (_heightMax - _heightMin) + _heightMin;
	height *= _planetRadiusHeightMapMultiplier;
	height += _planetRadiusStart;

	//DEBUG
	//height = 0;
	//height = clamp(height, 0, 1000);

	_vertices[id.x + id.y * _numberOfVerticesOnEdge] = dir * height;
}

double height01ToHeightReal(double height01)
{
	double heightReal = height01 * (_heightMax - _heightMin) + _heightMin;
	heightReal *= _planetRadiusHeightMapMultiplier;
	return heightReal;
}

[numthreads(1, 1, 1)]
void generateUsingChunkLocalPos(uint3 id : SV_DispatchThreadID)
{
	float maxId = _numberOfVerticesOnEdge - 1;
	float2 uv = float2(id.x / maxId, id.y / maxId);

	float3 unitCubePos = lerp(
		lerp(_rangeUnitCubePosA, _rangeUnitCubePosB, uv.x),
		lerp(_rangeUnitCubePosD, _rangeUnitCubePosC, uv.x),
		uv.y
	);

	float3 origin = normalize((_rangeUnitCubePosA + _rangeUnitCubePosB + _rangeUnitCubePosC + _rangeUnitCubePosD) / 4.0) * _planetRadiusStart;

	float3 dir = unitCubeToUnitSphere(unitCubePos);

	double height01 = _chunkHeightMap.SampleLevel(sampler_chunkHeightMap, uv, 0).r;
	double heightReal = height01ToHeightReal(height01) + _planetRadiusStart;
	
	double3 pos = dir * heightReal;

	double3 offset = 0;
	{

		double2 slopeXY = _chunkSlopeAndCurvatureMap.SampleLevel(sampler_chunkSlopeAndCurvatureMap, uv, 0).xy;
		double slope = saturate(length(slopeXY));

		double rockWeight = smoothstep(0.25, 1, slope);
		double height01Add = (1 - abs(snoise(pos / 500.0, 30, 1.5))) * rockWeight * 0.05;

		offset = (1 - abs(snoise_grad(pos / 500.0, 30, 1.5))) * rockWeight * 10;

		//heightReal += height01ToHeightReal(height01Add);
	}
	
	float craterOffset = 0;
	for (int i = 0; i < 100; ++i)
	{
		float4 c = _craterSpherePositionRadius[i];
		float d = distance(c.xyz, pos);
		float displacetMassHeight = c.w / 40.0;
		craterOffset += d < c.w ? 
			-smoothstep(c.w, c.w * 0.2, d) * c.w / 2.0 + displacetMassHeight: // inside of crater
 			smoothstep(c.w * 1.2f, c.w, d) * displacetMassHeight; // edge outside, displaced mass
		//craterOffset = min(craterOffset, -w);
	}

	heightReal += craterOffset;

	
	if (_moveEdgeVerticesDown > 0 && id.x == 0 || id.x == maxId || id.y == 0 || id.y == maxId)
	{
		heightReal -= _moveEdgeVerticesDown;
	}


	//DEBUG
	//height = 0;

	_vertices[id.x + id.y * _numberOfVerticesOnEdge] = dir * heightReal - origin + offset;
}

